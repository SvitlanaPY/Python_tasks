# zip(iterable1, iterable2, ... ) ---> zip object
# zip() приймає довільну к-сть ітерабельних послідовностей і повертає zip object,
# zip object є ітератором, а ітератор можна перетворити в будь-яку ін. колекцію, наприклад в ліст;
# Ф-ія zip() створює кілька кортежів із елементів тих ітерабельних колекція, які були їй передані,
# і в кожному кортежі знаходяться елементи, які стоять на однакових індексах в тих колекціях.
# Якщо колекції, які передаються у ф-ію zip(), будуть різної довжини,
# то ф-ія zip() сама визначить довжину найкоротшої послідовності, і відповідно зробить стільки ж зчеплень
# (по довжині найкоротшої послідовності)

a = [5, 6, 7, 8]
b = [500, 600, 700, 800]
for i in range(4):
    print(a[i], b[i])
# 5 500
# 6 600
# 7 700
# 8 800

rez = zip(a, b)
print(rez)    # <zip object at 0x7f6d43575740> - iterator

# над ітератором НЕ можна робити певних операцій:
# 1) print(len(rez)) ---> TypeError;
# 2) print(rez[0]) ==> TypeError;
# 3) також елементи ітератора можна обходити лише ОДИН раз:
for i in rez:
    print("rez1: ", i)
for i in rez:            # другий for не виконається
    print("rez2: ", i)   # другий for не виконається

# але ітератор можна перетворити в будь-яку ін. колекцію, наприклад в ліст чи в словник;
# щоб уникнути роботи з ітератором, одразу варто перетворювати результат ф-ії zip() обертати у ф-ію list()
# чи в ін. ітерабельну колекцію: list, dict, tuple
rez = list(zip(a, b))
print("into list: ", rez)
# [(5, 500), (6, 600), (7, 700), (8, 800)]

ddd = dict(zip(['Spain', 'Ukraine', 'USA'], ['Madrid', 'Kiev', 'Washington']))
print("into dict:  ", ddd)
# ddd =   {'Spain': 'Madrid', 'Ukraine': 'Kiev', 'USA': 'Washington'}

s1 = ['Spain', 'Ukraine', 'USA']
s2 = ('Madrid', 'Kiev', 'Washington')
s = tuple(zip(s1, s2))
print("into tuple:  ", s)


print()
a = [5, 6, 7, 8]
b = [500, 600, 700, 800]
c = "abcd"
rez2 = list(zip(a, b, c))
print(rez2)
# [(5, 500, 'a'), (6, 600, 'b'), (7, 700, 'c'), (8, 800, 'd')]

for i in zip(a, b, c):
    print(i)   # де i - є кортежем з трьох елементів
# # (5, 500, 'a')
# # (6, 600, 'b')
# # (7, 700, 'c')
# # (8, 800, 'd')

print("----------------")
rez_ = zip(a, b, c)
for i in rez_:
    print(i)
# (5, 500, 'a')
# (6, 600, 'b')
# (7, 700, 'c')
# (8, 800, 'd')

# множинне присвоєння:
for t1, t2, t3 in zip(a, b, c):
    print(f"t1 = {t1},   t2 = {t2},   t3 = {t3}")
# t1 = 5,   t2 = 500,   t3 = a
# t1 = 6,   t2 = 600,   t3 = b
# t1 = 7,   t2 = 700,   t3 = c
# t1 = 8,   t2 = 800,   t3 = d

# як із результату роботи ф-ії zip() назад отримати наші ітерабельні колекції:
a = [5, 6, 7, 8]
b = [500, 600, 700, 800]
c = 'abcd'
rez_back = zip(a, b, c)
print("rez_back:", list(zip(a, b, c)))
# rez_back: [(5, 500, 'a'), (6, 600, 'b'), (7, 700, 'c'), (8, 800, 'd')]

coll_1, coll_2, coll_3 = zip(*rez_back)
print("unpacked zip(): ", coll_1, coll_2, coll_3)
# unpacked zip():  (5, 6, 7, 8) (500, 600, 700, 800) ('a', 'b', 'c', 'd')
