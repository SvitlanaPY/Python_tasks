# ЛОГ - це журнал/протокол, в який записуєттся кажна дія користувача
# ЛОГЕР - це той, хто веде протокол.
# Це спец. об"єкти, в яких є кілька методів, викликаючи які ми визначаємо,
# які події будуть записані/залоговані, а які - ні.

# Коли ми викликаємо методи логера (.warning() ...), логери створюють всередині себе спеціальні об"єкти,
# які є екземплярами класу LogRecord і які містяь всю необхідну інформацію/дані про подію, що відбулась:
# це може бути імена ф-ій, в якиих ми викликали метод логера, ім"я модуля, де це відбулось, номер строки, час події...
# це все є LogRecord attributes (дані, що записуються в об"єкті LogRecord; це і є дані, що записуються в лог).
#
# у момент виклику метода warning(), логер створив екземпляр класу LogRecord.
# далі ці записи LogRecord-а направляються логером в хендлери логера - в HANDLER-и
# HANDLER - фільтрують отримані від логера повідомлення(LogRecord-об"єкти)
# і обробляють їх(записують в файл, чи виводять в консоль, чи пересилають по e-mail).
#
# Root-логер має дефолтний хендлер (StreamHandler), який виводить повідомлення в консоль.
# дефолтний хендлер отримав LogRecord-об"єкт від логера(купу атрибутів/інфи) і передає його у відповідний FORMATTER,
# який створить строку потрібного нам/заданого вигляду, поверне строку хендлеру, який виведе її назовні.
#
# !!!!!!!!!!!!!!!!!!!
# ОТЖЕ, є ТРИ об"єкта, які беруть участь у створенні запису в лог:
# 1. - LOGGER, об"єкт, що дає нам АРІ для запису повідомлень в лог;
# логери створюють LogRecord-об"єкти і направляють ці об"єкти (які містяь всю необхідну інформацію/дані) своїм хендлерам.
# 2. - HANDLER: зписують отримане повідомлення від LogRecord-а туди, куди нам потрібно
# (записують в файл, чи виводять в консоль, чи пересилають по e-mail...)
# але перш, ніж хендлер виконає свою задачу запису даних, він передає LogRecord-об"єкт у відповідний FORMATTER;
# 3. - FORMATTER: створить строку потрібного нам вигляду/темплейту.
#
# є П"ЯТЬ рівнів важливості повідомлень, кожен з яких має свій метод:
#  0-NOTSET
# 10-DEBUG
# 20-INFO
# 30-WARNING
# 40-ERROR
# 50-CRITICAL
# за замовчуванням у root-логера встановлений рівень логування 30-WARNING
# print("my_logger.level: ", my_logger.level)
# отже повідомлення з менш важливим рівнем (10-DEBUG та 20-INFO) НЕ будуть оброблятись root-логером;
# логер відфільтрує/проігнорує ці повідомлення і вони НЕ дійдуть до хендлера.
#
# Але рівень логування root-логера можна міняти за допомогою ф-ії/метода setLevel():
# my_logger.setLevel('DEBUG')
# або
# my_logger.setLevel(10)
# або
# my_logger.setLevel(logging.DEBUG())
# АЛЕ, у хендлера є СВІЙ рівень логування, який НЕ залежить від рівня логування root-логера;
# і зміннюючи рівень логування у root-логера, рівень повідомлень у його хендлера НЕ буде змінюватись;
# при потребі потрібно додатково змінювати рівень повідомлень для хендлера тією ж ф-ією.
# Отже у логерів і хендлерів є СВОЇ НЕЗАЛЕЖНІ рівні логування.
#
# Метод setLevel() визначає те, які саме повідомлення root-логер буде передавати своїм хендлерам
# (одному логеру ми можемо причепити кілька хендлерів)
# а метод setLevel() у відповідного хендлера root-логера визначає те, які повідомлення хендлер буде розсилати:
# (і ми можемо зробити так, що повідомлення рівня 10-DEBUG будуть записуватись в лог-файл, а
# повідомлення рівня 50-CRITICAL будуть пересидатись по e-mail)



import pprint
import logging

# створюємо об"єкт логера:
my_logger = logging.getLogger()
# ф-ія/метод getLogger() приймає один параметр - name, імя логера.
# Якщо у фі-ю getLogger() НЕ передано імені, то вона створює root-логер по замовчуванню.
print("my_logger: ", my_logger)
# <RootLogger root (WARNING)>   - екземпляр класу RootLogger з іменем root
print()

# pprint.pprint(dir(my_logger))

print("my_logger.level: ", my_logger.level)
# my_logger.level:  30


# логери мають свої хендлери:
print()
print("my_logger.handlers: ", my_logger.handlers)
# []
print()
# для НЕсконфігурованого root-логера, створюється хендлер типу StreamHandler з рівнем повідомлень 0-NOTSET
# (це означає, що хендлер буде обробляти ВСІ повідомлення),
# але він НЕ закріплюється за root-логером і тому ліст порожній... - [].
# З таким НЕсконфігурованим логером неможливо працювати.
# Для конфігурації root-логера модуль logging має спец. ф-ію basicConfig(),
# в якій може бути дуже багато параметрів/аргументів.
# basicConfig() перевіряє у root-логера наявність хендлерів, закріплених за root-логером,
# і якщо немає, то basicConfig() створює хендлер класу StreamHandler і закріплює його за root-логером.
# передаючи в basicConfig() аргумент filename, ми змінимо тип хендлера на FileHandler.

# викликаємо ф-ію basicConfig():
# logging.basicConfig(level='DEBUG', filename="mylog.log", filemode='a')
# або
# logging.basicConfig(level=logging.DEBUG, filename="mylog.log", filemode='a')
# або
# logging.basicConfig(level=10, filename="mylog.log", filemode='a')
# print("my_logger.handlers: ", my_logger.handlers)
# [<FileHandler /home/svitlana/Projects/Python_Tasks/LOGging/mylog.log (NOTSET)>]


def main(name):
    my_logger.warning(f"Enter in the main() function: name = {name}")
#   у момент виклику метода warning(), логер створив екземпляр класу LogRecord

# DEBUG:root:Enter in the main() function: name = oleg   # root - імя дефолтного логера


if __name__ == '__main__':
    main('oleg')
