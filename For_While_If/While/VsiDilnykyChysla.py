"""
ЛІНІЙНИЙ алгоритм пошуку дільників числа
# лінійний, бо час виконання лінійний - к-сть циклів виконання залежить від змінної n
# (якщо n = 20, то цикл буде виконуватись 20 раз)
#
# n = int(input())
# i = 1
# while i <= n:
#     if n % i == 0:
#         print(i, end=' ')
#     i += 1
"""


"""
якщо напр. n = 50, то його дільниками є:
1, 5, 10, 25, 50
видно, що після 25, вже немає дільників, а 25 - це 1/2 від 50
так само і для будь-якого іншого числа:
36: 1, 2, 3, 4, 6, 9, 12, 18, 36 
після 18, вже немає дільників; 18 - це 1/2 від 36.
Тобто алгоритм можна вдосконалити і цикл скоротити вдвічі: i <= n // 2
# n = int(input())
# i = 1  # i - дільник
# while i <= n // 2:
#     if n % i == 0:
#         print(i, end=' ')
#     i += 1
# print(n)
але це теж лінійний алгоритм, но чуть ефективнійший (пошук скорочено вдвічі)
"""

"""
Кожен дільник числа має пару: 
36: 
1 - 36
2 - 18
3 - 12
4 - 9
6 - 6
наше число n можна записати як добуток двох його дільників: n = a*b, 
(перемножуючи a і b ми отримуємо n), де 
один з дільників пари є меншим чи рівним іншому дільнику, який з ним в парі.
Нехай менший дільник - це а: a<=b
Найбільше значення, яке може мати а, це коли а буде буде рівне b: a=b;
Підставивши а у нашу формулу (n = a*b) отримаємо:
n = a*b = а*а
a = n**0,5
"""

# n = 36
# a: 1,  2,  3,  4, 6  - нехай a-найменший дільник
# b: 36, 18, 12, 9, 6
# n = a * b (перемножуючи a і b ми отримуємо n); b=n//a
# найбільше значення, яке може мати а, це коли а = b = 6
# отже, можна записати: n = a * a = a**2; звідси a = sqrt(n) = n**0.5
# знаючи а, b=n//a

n = int(input())
a = 1
lst_ = []
while a <= n ** 0.5:   # або a ** 2 <= n;  або a * a <= n
    if n % a == 0:
        if a == n // a:
            lst_.append(a)
            # print(a)
        else:
            lst_.append(a)
            lst_.append(n // a)
            # print(a, n // a)
    a += 1
lst_.sort()
print(lst_)
print(sum(lst_))

