"""
Генератор - це ітератор, елементи якого можна обійти в циклі лише ОДИН раз;
це такі ф-ії, в яких замість return вкористовується yield,
при цьому замість того, щоб нам повертати значення, ф-ія буде генерувати нам значення.

Ітератори підтримують виклик ф-ії next().

Функції-генератори: ф-ії які можуть повертати по одному значенню і при цьому заморожувати своє виконання і
при новому виклику нашої ф-ії, вона буде виконуватись з того місця, на якому вона зупинилась.
Функція-генератор запам"ятовує, який елемент вона останній раз за допомогою інструкції yield повертала і який елемент потрібно повернути наступним.
yield - повертає значення і заморожує виконання ф-ії,
і при кожному наступному звернені до цієї ф-ії-генератора, вона буде запускатись саме з рядка, який іде після yield.
"""

"""
генеруємо послідовність у зворотньому порядку:
звичайна ф-ія зберігає проміжний стан своєї роботи у списку. Список відіграє роль акумулятора проміжного результату.
І вкінці роботи, коли ф-ія відпрацює свою задачу, список повертається в те місце, звідки відбувся виклик ф-ії.

"""
def countdown(n):
    result = []
    while n != 0:
        result.append(n-1)
        n -= 1
    return result

print(countdown(4))   # [3, 2, 1, 0]


"""
Генератор теж генерує послідовність чисел у зворотньому порядку, но повертає він цю послідовність частинами,
тобто оператор yield частинами генерує послідовність і частинами повертає цю послідовність по одному елементу.
Ми присвоюємо виклик генератора в змінну g: g = gen_countdown(4)
і тоді цю g передали у вбудовану ф-ію next()
При кожному наступному зверненню до ф-ії-генератора, ми будемо отримувати наступний елемент послідовності.
next() - це вбудована ф-ія, яку використовують цикли while та for, для того щоб прокручувати всередині себе ітерабельні об"єкти
бо кожен ітерабельний об"єкт реалізує протоком ітераторів, за допомогою ф-ії iter() та next().
"""

def gen_countdown(n):
    while n != 0:
        yield n-1
        n -= 1

# g = gen_countdown(4)
# print(g)   # <generator object gen_countdown at 0x7ff950f83b30>
# print(next(g))   # 3
# print(next(g))   # 2

for i in gen_countdown(4):   # або:  for i in g:
    print(i, end=' ')
    # 3 2 1 0

"""
І звичайна ф-ія, і ф-ія генератор повертають нам послідовності: 
звичайна ф-ія повертає послідовність всю і одразу, а ф-ія-генератор віддає її частинами при наступному зверненні до ф-ії
(є наступне звернення до ф-ії-генератора, то буде повертатись наступний елемент послідовності).
Це основна перевага генераторів - 
ми не витрачаємо памяті і ресурсів нашого компа на зберігання ні проміжного результату, ні кінцевого результату.

Звичайні ф-ії використовують тоді, коли потрібно звертатись до елементів колекції кілька разів.
Генератори НЕ підтримують звернення до елементів колекції по індексу.
Генератори використовуються, якщо необхідно обробляти дуже великі послідовності даних, і при цьому нам невідомо, чи потрібно нам буде всі ці дані, чи лише перших 10...
наприклад коли ми на амазоні робимо запит по якомусь бренду (asus), то не потрібно одразу видавати всі-всі результати пошуку, а лише наприклад, перші 20,
а вже коли ми перейдемо на наступну сторінку - видати іншу частину даних.
"""

"""
Генератор - це такий зручний синтаксис для написання ітераторів,
генератор поводить себе майже так само як і функція, но при цьому за допомогою конструкції yield, 
ми можемо повертати одразу кілька значень із функції.
Виконання тіла функції відбувається лише тоді, коли ми викликаємо __next__ і відбувається від одного yield-а до іншого yield-а,
а якщо наступного yield-а не знайдено, то тоді генератор завершує своє виконання і кидає помилку StopIteration.
"""